HTML<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>–ó–≤–æ–Ω–∫–∏ (WebRTC + Opus) ‚Äî –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞</title>
  <meta name="description" content="–ê—É–¥–∏–æ–∑–≤–æ–Ω–∫–∏ —á–µ—Ä–µ–∑ WebRTC –∏ Opus –±–µ–∑ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞. –†–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–º —Ö–æ—Å—Ç–∏–Ω–≥–µ (Vercel/Replit)." />
  <link rel="icon" href="data:,">
  <style>
    :root {
      --bg: #0f1220;
      --panel: #151934;
      --text: #e9ecf1;
      --muted: #a9b0c3;
      --accent: #7c9cff;
      --ok: #34d399;
      --warn: #f59e0b;
      --err: #ef4444;
      --border: #28304f;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; height: 100%; }
    body {
      font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
      color: var(--text);
      background: radial-gradient(1200px 1200px at 10% 10%, #151934 0%, #0f1220 45%, #0a0d1a 100%);
      overflow-y: auto;
    }
    .wrap {
      max-width: 900px;
      margin: 32px auto;
      padding: 0 16px;
    }
    .card {
      background: rgba(21, 25, 52, 0.88);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      backdrop-filter: blur(6px);
    }
    h1 {
      margin: 0 0 12px 0;
      font-size: 22px; font-weight: 700;
      display: flex; align-items: center; gap: 8px;
    }
    .sub { color: var(--muted); margin-bottom: 14px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 1 1 auto; }
    input[type="text"] {
      background: #0f132a;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 14px;
      outline: none;
      width: 100%;
      transition: border-color .15s ease;
      font-size: 15px;
    }
    input[type="text"]:focus { border-color: var(--accent); }
    button {
      background: linear-gradient(180deg, #6c8cff 0%, #5a7bff 100%);
      color: white;
      border: none;
      border-radius: 10px;
      padding: 12px 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform .06s ease, filter .2s ease;
      user-select: none;
      white-space: nowrap;
    }
    button.secondary {
      background: #21284a;
      color: #dbe1ff;
      border: 1px solid #2c3563;
    }
    button:disabled { filter: grayscale(.6) brightness(.85); cursor: not-allowed; }
    button:active { transform: translateY(1px); }
    .grid {
      display: grid; gap: 14px; margin-top: 16px;
      grid-template-columns: repeat(12, 1fr);
    }
    .panel {
      background: #0f132a;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
    }
    .panel h3 { margin: 0 0 10px 0; font-size: 14px; color: var(--muted); }
    .status {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
      font-size: 14px;
    }
    .badge {
      display: inline-flex; align-items: center; gap: 6px;
      border-radius: 999px; padding: 6px 10px; font-size: 12px; font-weight: 600;
      border: 1px solid var(--border);
      background: #121738;
      color: #dfe6ff;
    }
    .badge.ok { background: rgba(52, 211, 153, .12); color: #bbf7d0; border-color: rgba(52, 211, 153, .25); }
    .badge.warn { background: rgba(245, 158, 11, .12); color: #fde68a; border-color: rgba(245, 158, 11, .25); }
    .badge.err { background: rgba(239, 68, 68, .12); color: #fecaca; border-color: rgba(239, 68, 68, .25); }
    .controls { display: flex; gap: 10px; flex-wrap: wrap; }
    .meter {
      height: 10px; border-radius: 6px; background: #0c1124; border: 1px solid var(--border);
      overflow: hidden; position: relative;
    }
    .meter > i {
      position: absolute; left: 0; top: 0; bottom: 0; width: 0%;
      background: linear-gradient(90deg, #34d399 0%, #f59e0b 60%, #ef4444 100%);
      transition: width .08s linear;
    }
    .caption { color: var(--muted); font-size: 12px; margin-top: 6px; }
    .small { font-size: 12px; color: var(--muted); }
    code.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; padding: 2px 6px; border: 1px solid var(--border); border-radius: 6px; background: #0f132a; color: #dbe1ff; }
    .logs { height: 160px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; background: #0c1124; border-radius: 8px; border: 1px solid var(--border); padding: 10px; white-space: pre-wrap; }
    .hint { color: var(--muted); }
    @media (max-width: 860px) {
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>üîä –í–µ–±-–∑–≤–æ–Ω–∫–∏ –Ω–∞ Opus (WebRTC, –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞)</h1>
    <div class="sub">–û–¥–Ω–æ—Å—Ç—Ä–∞–Ω–∏—á–Ω—ã–π –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä –¥–ª—è –∞—É–¥–∏–æ-–∑–≤–æ–Ω–∫–æ–≤. –†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è –∫–∞–∫ —Å—Ç–∞—Ç–∏–∫ (Vercel/Replit). –°–∏–≥–Ω–∞–ª–∏–Ω–≥ ‚Äî –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –æ–±–ª–∞—á–Ω—ã–π PeerJS; NAT ‚Äî –ø—É–±–ª–∏—á–Ω—ã–µ STUN. –ö–æ–¥–µ–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî Opus 48 kHz.</div>

    <div class="row" style="margin-bottom: 10px;">
      <input id="callId" type="text" placeholder="ID –∑–≤–æ–Ω–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: team-42)" autocomplete="off" />
      <button id="startBtn">–°—Ç–∞—Ä—Ç / –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
      <button id="copyBtn" class="secondary" title="–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É —Å ID">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É</button>
    </div>

    <div class="grid">
      <div class="panel" style="grid-column: span 8;">
        <h3>–°—Ç–∞—Ç—É—Å</h3>
        <div class="status" id="status">
          <span class="badge">–ù–µ –∑–∞–ø—É—â–µ–Ω–æ</span>
        </div>
        <div class="controls" style="margin-top: 12px;">
          <button id="muteBtn" class="secondary" disabled>–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω</button>
          <button id="hangBtn" class="secondary" disabled>–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
        </div>
        <div class="row" style="margin-top: 12px;">
          <div style="flex:1">
            <div class="small">–õ–æ–∫–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å</div>
            <div class="meter"><i id="mLocal"></i></div>
          </div>
          <div style="flex:1">
            <div class="small">–£–¥–∞–ª—ë–Ω–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å</div>
            <div class="meter"><i id="mRemote"></i></div>
          </div>
        </div>
      </div>

      <div class="panel" style="grid-column: span 4;">
        <h3>–¢–µ–∫—É—â–∞—è —Å–µ—Å—Å–∏—è</h3>
        <div class="small">–†–æ–ª—å: <span id="role">‚Äî</span></div>
        <div class="small">ID –∑–≤–æ–Ω–∫–∞: <code id="cid" class="mono">‚Äî</code></div>
        <div class="small">Codec (inbound): <span id="codec" class="badge warn">–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ</span></div>
        <div class="small">ICE: <span id="ice" class="badge">‚Äî</span></div>
        <div class="hint" style="margin-top:10px;">
          –°—Å—ã–ª–∫–∞ –Ω–∞ –∑–≤–æ–Ω–æ–∫ —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ URL (#id). –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—ë —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫—É ‚Äî –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å —Ç–µ–º –∂–µ ID –≤—Ç–æ—Ä–æ–π —É—á–∞—Å—Ç–Ω–∏–∫ –ø–æ–¥–∫–ª—é—á–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.
        </div>
      </div>

      <div class="panel" style="grid-column: span 12;">
        <h3>–õ–æ–≥–∏</h3>
        <div class="logs" id="logs"></div>
      </div>
    </div>
  </div>
</div>

<!-- –°–∫—Ä—ã—Ç—ã–µ –∞—É–¥–∏–æ —ç–ª–µ–º–µ–Ω—Ç—ã -->
<audio id="localAudio" autoplay muted playsinline></audio>
<audio id="remoteAudio" autoplay playsinline></audio>

<!-- PeerJS —Å CDN (–æ–±–ª–∞—á–Ω—ã–π —Å–∏–≥–Ω–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä 0.peerjs.com) -->
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
(() => {
  const els = {
    callId: document.getElementById('callId'),
    startBtn: document.getElementById('startBtn'),
    copyBtn: document.getElementById('copyBtn'),
    muteBtn: document.getElementById('muteBtn'),
    hangBtn: document.getElementById('hangBtn'),
    status: document.getElementById('status'),
    cid: document.getElementById('cid'),
    role: document.getElementById('role'),
    codec: document.getElementById('codec'),
    ice: document.getElementById('ice'),
    logs: document.getElementById('logs'),
    localAudio: document.getElementById('localAudio'),
    remoteAudio: document.getElementById('remoteAudio'),
    mLocal: document.getElementById('mLocal'),
    mRemote: document.getElementById('mRemote'),
  };

  const ICE_SERVERS = [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
  ];
  const PEER_OPTS = {
    debug: 1,
    // signaling ‚Äî –æ–±–ª–∞—á–Ω—ã–π —Å–µ—Ä–≤–µ—Ä PeerJS (0.peerjs.com) –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    config: { iceServers: ICE_SERVERS }
  };

  let peer = null;
  let isHost = false;
  let call = null;
  let localStream = null;
  let statsTimer = null;
  let audioCtx, localAnalyser, remoteAnalyser, rafId;

  const log = (...args) => {
    const msg = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
    const time = new Date().toLocaleTimeString();
    els.logs.textContent += `[${time}] ${msg}\n`;
    els.logs.scrollTop = els.logs.scrollHeight;
    console.log('[LOG]', ...args);
  };
  const setStatus = (...badges) => {
    els.status.innerHTML = '';
    badges.forEach(b => els.status.appendChild(b));
  };
  const badge = (text, type='') => {
    const s = document.createElement('span');
    s.className = 'badge' + (type ? ' ' + type : '');
    s.textContent = text;
    return s;
  };

  const sanitizeId = (s) => (s || '')
    .toLowerCase()
    .replace(/[^a-z0-9_-]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .slice(0, 48);

  const randomId = () =>
    Math.random().toString(36).slice(2, 6) + '-' + Math.random().toString(36).slice(2, 6);

  const callHostId = (callId) => `call-${callId}-host`;

  const updateUrlHash = (callId) => {
    const url = location.origin + location.pathname + '#' + encodeURIComponent(callId);
    history.replaceState(null, '', url);
  };
  const copyLink = async () => {
    const callId = sanitizeId(els.callId.value);
    if (!callId) return;
    const url = location.origin + location.pathname + '#' + encodeURIComponent(callId);
    try {
      await navigator.clipboard.writeText(url);
      setStatus(badge('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞', 'ok'));
    } catch {
      setStatus(badge('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å', 'err'));
    }
  };

  const setupAudioMeters = (localStream, remoteStream) => {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const createMeter = (stream, analyserRef, meterEl) => {
        const source = audioCtx.createMediaStreamSource(stream);
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256;
        analyserRef.node = analyser;
        source.connect(analyser);
        const data = new Uint8Array(analyser.frequencyBinCount);
        const draw = () => {
          analyser.getByteTimeDomainData(data);
          let peak = 0;
          for (let i = 0; i < data.length; i++) {
            const v = (data[i] - 128) / 128;
            peak = Math.max(peak, Math.abs(v));
          }
          const pct = Math.min(100, Math.max(0, Math.round(peak * 160)));
          meterEl.style.width = pct + '%';
        };
        return draw;
      };
      localAnalyser = {};
      remoteAnalyser = {};
      const draws = [];
      if (localStream) draws.push(createMeter(localStream, localAnalyser, els.mLocal));
      if (remoteStream) draws.push(createMeter(remoteStream, remoteAnalyser, els.mRemote));
      const loop = () => {
        draws.forEach(fn => fn());
        rafId = requestAnimationFrame(loop);
      };
      loop();
    } catch (e) {
      log('Meters init error:', e?.message || e);
    }
  };

  const stopMeters = () => {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
    els.mLocal.style.width = '0%';
    els.mRemote.style.width = '0%';
    try { audioCtx && audioCtx.close(); } catch {}
    audioCtx = null;
  };

  const getMedia = async () => {
    const constraints = {
      audio: {
        channelCount: 2,
        sampleRate: 48000,
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      },
      video: false
    };
    log('–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É‚Ä¶');
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    els.localAudio.srcObject = stream;
    try { await els.localAudio.play(); } catch {}
    return stream;
  };

  const startStatsMonitor = (pc) => {
    clearInterval(statsTimer);
    statsTimer = setInterval(async () => {
      try {
        const stats = await pc.getStats();
        let codecLabel = null;
        let selectedCandidatePairId = null, candidatePair = null, localCand = null, remoteCand = null;

        stats.forEach(report => {
          if (report.type === 'inbound-rtp' && report.kind === 'audio' && report.codecId) {
            const codec = stats.get(report.codecId);
            if (codec && codec.mimeType) codecLabel = codec.mimeType + (codec.sdpFmtpLine ? ` (${codec.sdpFmtpLine})` : '');
          }
          if (report.type === 'transport' && report.selectedCandidatePairId) {
            selectedCandidatePairId = report.selectedCandidatePairId;
          }
        });
        if (selectedCandidatePairId) candidatePair = stats.get(selectedCandidatePairId);
        if (candidatePair) {
          localCand = stats.get(candidatePair.localCandidateId);
          remoteCand = stats.get(candidatePair.remoteCandidateId);
        }

        if (codecLabel) {
          els.codec.textContent = codecLabel;
          els.codec.className = 'badge ok';
        }
        if (localCand && remoteCand) {
          const text = `${localCand.protocol || 'udp'} ¬∑ ${localCand.candidateType} ‚áÑ ${remoteCand.candidateType}`;
          els.ice.textContent = text;
          els.ice.className = 'badge';
        }
      } catch (e) {
        // ignore single errors
      }
    }, 1500);
  };

  const cleanup = () => {
    if (call) { try { call.close(); } catch {} call = null; }
    if (peer) { try { peer.destroy(); } catch {} peer = null; }
    if (localStream) {
      localStream.getTracks().forEach(t => { try { t.stop(); } catch {} });
      localStream = null;
    }
    if (els.remoteAudio.srcObject) {
      const rs = els.remoteAudio.srcObject;
      if (rs && rs.getTracks) rs.getTracks().forEach(t => t.stop());
      els.remoteAudio.srcObject = null;
    }
    els.localAudio.srcObject = null;
    stopMeters();
    clearInterval(statsTimer);
    statsTimer = null;
    els.muteBtn.disabled = true;
    els.hangBtn.disabled = true;
    els.muteBtn.textContent = '–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω';
    setStatus(badge('–û—Ç–∫–ª—é—á–µ–Ω–æ'));
    els.role.textContent = '‚Äî';
    els.cid.textContent = '‚Äî';
    els.codec.textContent = '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
    els.codec.className = 'badge warn';
    els.ice.textContent = '‚Äî';
  };

  const attachCallHandlers = (mc) => {
    call = mc;
    const pc = mc.peerConnection || mc._pc || null;

    mc.on('stream', async (remoteStream) => {
      log('–ü–æ–ª—É—á–µ–Ω —É–¥–∞–ª—ë–Ω–Ω—ã–π –ø–æ—Ç–æ–∫');
      els.remoteAudio.srcObject = remoteStream;
      try { await els.remoteAudio.play(); } catch {}
      setupAudioMeters(localStream, remoteStream);
      els.muteBtn.disabled = false;
      els.hangBtn.disabled = false;
      if (pc) startStatsMonitor(pc);
    });

    mc.on('close', () => {
      log('–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à—ë–Ω');
      setStatus(badge('–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à—ë–Ω', 'warn'));
      cleanup();
    });

    mc.on('error', (e) => {
      log('–û—à–∏–±–∫–∞ –∑–≤–æ–Ω–∫–∞:', e?.type || e?.message || e);
      setStatus(badge('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è', 'err'));
    });

    if (pc) {
      pc.addEventListener('iceconnectionstatechange', () => {
        log('ICE state:', pc.iceConnectionState);
        if (pc.iceConnectionState === 'failed') {
          els.ice.className = 'badge err';
        }
      });
    }
  };

  const becomeHost = async (hostId) => {
    return new Promise((resolve, reject) => {
      peer = new Peer(hostId, PEER_OPTS);
      peer.on('open', id => {
        log('–ú—ã ‚Äî —Ö–æ—Å—Ç, ID:', id);
        isHost = true;
        els.role.textContent = '–•–æ—Å—Ç (–æ–∂–∏–¥–∞–Ω–∏–µ)';
        resolve(true);
      });
      peer.on('error', (e) => {
        log('Peer error (host):', e?.type || e?.message || e);
        if (e && (e.type === 'unavailable-id' || /taken|unavailable/i.test(e.message))) {
          resolve(false); // ID –∑–∞–Ω—è—Ç ‚Äî –±—É–¥–µ–º –∑–≤–æ–Ω–∏—Ç—å
        } else {
          reject(e);
        }
      });
      peer.on('call', (incoming) => {
        log('–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫ ‚Äî –æ—Ç–≤–µ—á–∞–µ–º');
        try {
          incoming.answer(localStream, { metadata: { opus: true } });
          attachCallHandlers(incoming);
          setStatus(badge('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ', 'ok'));
          els.role.textContent = '–•–æ—Å—Ç (–≤ –∑–≤–æ–Ω–∫–µ)';
        } catch (e) {
          log('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–≤–µ—Ç–∏—Ç—å:', e?.message || e);
          setStatus(badge('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ', 'err'));
        }
      });
    });
  };

  const becomeCaller = async (hostId) => {
    return new Promise((resolve, reject) => {
      peer = new Peer(undefined, PEER_OPTS);
      peer.on('open', () => {
        log('–ú—ã ‚Äî –∑–≤–æ–Ω—è—â–∏–π, PeerID:', peer.id);
        isHost = false;
        els.role.textContent = '–ö–ª–∏–µ–Ω—Ç (–∑–≤–æ–Ω—è—â–∏–π)';
        try {
          const mc = peer.call(hostId, localStream, { metadata: { opus: true } });
          if (!mc) {
            setStatus(badge('–•–æ—Å—Ç –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç', 'warn'));
            return reject(new Error('No media connection'));
          }
          attachCallHandlers(mc);
          setStatus(badge('–ó–≤–æ–Ω–∏–º‚Ä¶'));
          resolve(true);
        } catch (e) {
          log('–û—à–∏–±–∫–∞ –≤—ã–∑–æ–≤–∞:', e?.message || e);
          setStatus(badge('–û—à–∏–±–∫–∞ –≤—ã–∑–æ–≤–∞', 'err'));
          reject(e);
        }
      });
      peer.on('error', (e) => {
        log('Peer error (caller):', e?.type || e?.message || e);
        setStatus(badge('–û—à–∏–±–∫–∞ peer', 'err'));
      });
    });
  };

  const startOrJoin = async () => {
    els.startBtn.disabled = true;
    els.copyBtn.disabled = true;
    setStatus(badge('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è‚Ä¶'));

    let callId = sanitizeId(els.callId.value);
    if (!callId) callId = randomId();
    els.callId.value = callId;
    els.cid.textContent = callId;
    updateUrlHash(callId);

    try {
      localStream = await getMedia();
    } catch (e) {
      log('–î–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –æ—Ç–∫–ª–æ–Ω—ë–Ω:', e?.message || e);
      setStatus(badge('–ù—É–∂–µ–Ω –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É', 'err'));
      els.startBtn.disabled = false; els.copyBtn.disabled = false;
      return;
    }

    const hostId = callHostId(callId);
    setStatus(badge('–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ —Å–∏–≥–Ω–∞–ª—å–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—É‚Ä¶'));
    let hosting;
    try {
      hosting = await becomeHost(hostId);
    } catch (e) {
      log('–û—à–∏–±–∫–∞ —Å–∏–≥–Ω–∞–ª—å–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞:', e?.message || e);
      setStatus(badge('–°–∏–≥–Ω–∞–ª–∏–Ω–≥ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω', 'err'));
      els.startBtn.disabled = false; els.copyBtn.disabled = false;
      return;
    }

    if (!hosting) {
      // –•–æ—Å—Ç —É–∂–µ –µ—Å—Ç—å ‚Äî –∑–≤–æ–Ω–∏–º
      try {
        await becomeCaller(hostId);
      } catch (e) {
        setStatus(badge('–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–∑–≤–æ–Ω–∏—Ç—å—Å—è', 'err'));
      }
    } else {
      // –ú—ã ‚Äî —Ö–æ—Å—Ç –∏ –∂–¥—ë–º
      setStatus(badge('–ñ–¥—ë–º –≤—Ç–æ—Ä–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞‚Ä¶', 'warn'));
    }

    els.hangBtn.disabled = false;
    els.copyBtn.disabled = false;
  };

  const hangup = () => {
    cleanup();
    els.startBtn.disabled = false;
  };

  const toggleMute = () => {
    if (!localStream) return;
    const track = localStream.getAudioTracks()[0];
    if (!track) return;
    track.enabled = !track.enabled;
    els.muteBtn.textContent = track.enabled ? '–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω' : '–í–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω';
  };

  // Wire UI
  els.startBtn.addEventListener('click', startOrJoin);
  els.copyBtn.addEventListener('click', copyLink);
  els.hangBtn.addEventListener('click', hangup);
  els.muteBtn.addEventListener('click', toggleMute);

  // –ê–≤—Ç–æ–ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∞ ID –∏–∑ URL
  const hashId = decodeURIComponent((location.hash || '').replace(/^#/, ''));
  if (hashId) {
    els.callId.value = sanitizeId(hashId);
  }

  // –ü–æ–ª–µ–∑–Ω—ã–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏
  log('–ì–æ—Ç–æ–≤–æ. –í–≤–µ–¥–∏—Ç–µ –æ–±—â–∏–π ID –∑–≤–æ–Ω–∫–∞ –∏ –Ω–∞–∂–º–∏—Ç–µ "–°—Ç–∞—Ä—Ç / –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è".');
  log('–ü–µ—Ä–≤—ã–π, –∫—Ç–æ –∑–∞–π–¥—ë—Ç —Å ID, —Å—Ç–∞–Ω–µ—Ç —Ö–æ—Å—Ç–æ–º (–æ–∂–∏–¥–∞–Ω–∏–µ); –≤—Ç–æ—Ä–æ–π ‚Äî –¥–æ–∑–≤–æ–Ω–∏—Ç—Å—è –∫ –Ω–µ–º—É –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.');
  log('Codec: –í —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –±—Ä–∞—É–∑–µ—Ä–∞—Ö –¥–ª—è –∞—É–¥–∏–æ WebRTC –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–±–∏—Ä–∞–µ—Ç Opus 48kHz.');
  log('–ü–æ–¥ –∫–∞–ø–æ—Ç–æ–º: PeerJS (–æ–±–ª–∞—á–Ω—ã–π signaling), STUN Google. –î–ª—è –∂—ë—Å—Ç–∫–∏—Ö NAT –º–æ–∂–µ—Ç –ø–æ–Ω–∞–¥–æ–±–∏—Ç—å—Å—è TURN (–Ω–µ –≤—Ö–æ–¥–∏—Ç).');
})();
</script>
</body>
</html>

==================================================

<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>–ó–≤–æ–Ω–∫–∏ (WebRTC + Opus) ‚Äî –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞</title>
  <meta name="description" content="–ê—É–¥–∏–æ–∑–≤–æ–Ω–∫–∏ —á–µ—Ä–µ–∑ WebRTC –∏ Opus –±–µ–∑ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞. –†–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–º —Ö–æ—Å—Ç–∏–Ω–≥–µ (Vercel/Replit)." />
  <link rel="icon" href="data:,">
  <style>
    :root {
      --bg: #0f1220;
      --panel: #151934;
      --text: #e9ecf1;
      --muted: #a9b0c3;
      --accent: #7c9cff;
      --ok: #34d399;
      --warn: #f59e0b;
      --err: #ef4444;
      --border: #28304f;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; height: 100%; }
    body {
      font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
      color: var(--text);
      background: radial-gradient(1200px 1200px at 10% 10%, #151934 0%, #0f1220 45%, #0a0d1a 100%);
      overflow-y: auto;
    }
    .wrap {
      max-width: 900px;
      margin: 32px auto;
      padding: 0 16px;
    }
    .card {
      background: rgba(21, 25, 52, 0.88);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      backdrop-filter: blur(6px);
    }
    h1 {
      margin: 0 0 12px 0;
      font-size: 22px; font-weight: 700;
      display: flex; align-items: center; gap: 8px;
    }
    .sub { color: var(--muted); margin-bottom: 14px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 1 1 auto; }
    input[type="text"] {
      background: #0f132a;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 14px;
      outline: none;
      width: 100%;
      transition: border-color .15s ease;
      font-size: 15px;
    }
    input[type="text"]:focus { border-color: var(--accent); }
    button {
      background: linear-gradient(180deg, #6c8cff 0%, #5a7bff 100%);
      color: white;
      border: none;
      border-radius: 10px;
      padding: 12px 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform .06s ease, filter .2s ease;
      user-select: none;
      white-space: nowrap;
    }
    button.secondary {
      background: #21284a;
      color: #dbe1ff;
      border: 1px solid #2c3563;
    }
    button:disabled { filter: grayscale(.6) brightness(.85); cursor: not-allowed; }
    button:active { transform: translateY(1px); }
    .grid {
      display: grid; gap: 14px; margin-top: 16px;
      grid-template-columns: repeat(12, 1fr);
    }
    .panel {
      background: #0f132a;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
    }
    .panel h3 { margin: 0 0 10px 0; font-size: 14px; color: var(--muted); }
    .status {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
      font-size: 14px;
    }
    .badge {
      display: inline-flex; align-items: center; gap: 6px;
      border-radius: 999px; padding: 6px 10px; font-size: 12px; font-weight: 600;
      border: 1px solid var(--border);
      background: #121738;
      color: #dfe6ff;
    }
    .badge.ok { background: rgba(52, 211, 153, .12); color: #bbf7d0; border-color: rgba(52, 211, 153, .25); }
    .badge.warn { background: rgba(245, 158, 11, .12); color: #fde68a; border-color: rgba(245, 158, 11, .25); }
    .badge.err { background: rgba(239, 68, 68, .12); color: #fecaca; border-color: rgba(239, 68, 68, .25); }
    .controls { display: flex; gap: 10px; flex-wrap: wrap; }
    .meter {
      height: 10px; border-radius: 6px; background: #0c1124; border: 1px solid var(--border);
      overflow: hidden; position: relative;
    }
    .meter > i {
      position: absolute; left: 0; top: 0; bottom: 0; width: 0%;
      background: linear-gradient(90deg, #34d399 0%, #f59e0b 60%, #ef4444 100%);
      transition: width .08s linear;
    }
    .caption { color: var(--muted); font-size: 12px; margin-top: 6px; }
    .small { font-size: 12px; color: var(--muted); }
    code.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; padding: 2px 6px; border: 1px solid var(--border); border-radius: 6px; background: #0f132a; color: #dbe1ff; }
    .logs { height: 160px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; background: #0c1124; border-radius: 8px; border: 1px solid var(--border); padding: 10px; white-space: pre-wrap; }
    .hint { color: var(--muted); }
    @media (max-width: 860px) {
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>üîä –í–µ–±-–∑–≤–æ–Ω–∫–∏ –Ω–∞ Opus (WebRTC, –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞)</h1>
    <div class="sub">–û–¥–Ω–æ—Å—Ç—Ä–∞–Ω–∏—á–Ω—ã–π –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä –¥–ª—è –∞—É–¥–∏–æ-–∑–≤–æ–Ω–∫–æ–≤. –†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è –∫–∞–∫ —Å—Ç–∞—Ç–∏–∫ (Vercel/Replit). –°–∏–≥–Ω–∞–ª–∏–Ω–≥ ‚Äî –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –æ–±–ª–∞—á–Ω—ã–π PeerJS; NAT ‚Äî –ø—É–±–ª–∏—á–Ω—ã–µ STUN. –ö–æ–¥–µ–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî Opus 48 kHz.</div>

    <div class="row" style="margin-bottom: 10px;">
      <input id="callId" type="text" placeholder="ID –∑–≤–æ–Ω–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: team-42)" autocomplete="off" />
      <button id="startBtn">–°—Ç–∞—Ä—Ç / –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
      <button id="copyBtn" class="secondary" title="–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É —Å ID">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É</button>
    </div>

    <div class="grid">
      <div class="panel" style="grid-column: span 8;">
        <h3>–°—Ç–∞—Ç—É—Å</h3>
        <div class="status" id="status">
          <span class="badge">–ù–µ –∑–∞–ø—É—â–µ–Ω–æ</span>
        </div>
        <div class="controls" style="margin-top: 12px;">
          <button id="muteBtn" class="secondary" disabled>–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω</button>
          <button id="hangBtn" class="secondary" disabled>–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
        </div>
        <div class="row" style="margin-top: 12px;">
          <div style="flex:1">
            <div class="small">–õ–æ–∫–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å</div>
            <div class="meter"><i id="mLocal"></i></div>
          </div>
          <div style="flex:1">
            <div class="small">–£–¥–∞–ª—ë–Ω–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å</div>
            <div class="meter"><i id="mRemote"></i></div>
          </div>
        </div>
      </div>

      <div class="panel" style="grid-column: span 4;">
        <h3>–¢–µ–∫—É—â–∞—è —Å–µ—Å—Å–∏—è</h3>
        <div class="small">–†–æ–ª—å: <span id="role">‚Äî</span></div>
        <div class="small">ID –∑–≤–æ–Ω–∫–∞: <code id="cid" class="mono">‚Äî</code></div>
        <div class="small">Codec (inbound): <span id="codec" class="badge warn">–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ</span></div>
        <div class="small">ICE: <span id="ice" class="badge">‚Äî</span></div>
        <div class="hint" style="margin-top:10px;">
          –°—Å—ã–ª–∫–∞ –Ω–∞ –∑–≤–æ–Ω–æ–∫ —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ URL (#id). –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—ë —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫—É ‚Äî –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å —Ç–µ–º –∂–µ ID –≤—Ç–æ—Ä–æ–π —É—á–∞—Å—Ç–Ω–∏–∫ –ø–æ–¥–∫–ª—é—á–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.
        </div>
      </div>

      <div class="panel" style="grid-column: span 12;">
        <h3>–õ–æ–≥–∏</h3>
        <div class="logs" id="logs"></div>
      </div>
    </div>
  </div>
</div>

<!-- –°–∫—Ä—ã—Ç—ã–µ –∞—É–¥–∏–æ —ç–ª–µ–º–µ–Ω—Ç—ã -->
<audio id="localAudio" autoplay muted playsinline></audio>
<audio id="remoteAudio" autoplay playsinline></audio>

<!-- PeerJS —Å CDN (–æ–±–ª–∞—á–Ω—ã–π —Å–∏–≥–Ω–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä 0.peerjs.com) -->
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
(() => {
  const els = {
    callId: document.getElementById('callId'),
    startBtn: document.getElementById('startBtn'),
    copyBtn: document.getElementById('copyBtn'),
    muteBtn: document.getElementById('muteBtn'),
    hangBtn: document.getElementById('hangBtn'),
    status: document.getElementById('status'),
    cid: document.getElementById('cid'),
    role: document.getElementById('role'),
    codec: document.getElementById('codec'),
    ice: document.getElementById('ice'),
    logs: document.getElementById('logs'),
    localAudio: document.getElementById('localAudio'),
    remoteAudio: document.getElementById('remoteAudio'),
    mLocal: document.getElementById('mLocal'),
    mRemote: document.getElementById('mRemote'),
  };

  const ICE_SERVERS = [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
  ];
  const PEER_OPTS = {
    debug: 1,
    // signaling ‚Äî –æ–±–ª–∞—á–Ω—ã–π —Å–µ—Ä–≤–µ—Ä PeerJS (0.peerjs.com) –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    config: { iceServers: ICE_SERVERS }
  };

  let peer = null;
  let isHost = false;
  let call = null;
  let localStream = null;
  let statsTimer = null;
  let audioCtx, localAnalyser, remoteAnalyser, rafId;

  const log = (...args) => {
    const msg = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
    const time = new Date().toLocaleTimeString();
    els.logs.textContent += `[${time}] ${msg}\n`;
    els.logs.scrollTop = els.logs.scrollHeight;
    console.log('[LOG]', ...args);
  };
  const setStatus = (...badges) => {
    els.status.innerHTML = '';
    badges.forEach(b => els.status.appendChild(b));
  };
  const badge = (text, type='') => {
    const s = document.createElement('span');
    s.className = 'badge' + (type ? ' ' + type : '');
    s.textContent = text;
    return s;
  };

  const sanitizeId = (s) => (s || '')
    .toLowerCase()
    .replace(/[^a-z0-9_-]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .slice(0, 48);

  const randomId = () =>
    Math.random().toString(36).slice(2, 6) + '-' + Math.random().toString(36).slice(2, 6);

  const callHostId = (callId) => `call-${callId}-host`;

  const updateUrlHash = (callId) => {
    const url = location.origin + location.pathname + '#' + encodeURIComponent(callId);
    history.replaceState(null, '', url);
  };
  const copyLink = async () => {
    const callId = sanitizeId(els.callId.value);
    if (!callId) return;
    const url = location.origin + location.pathname + '#' + encodeURIComponent(callId);
    try {
      await navigator.clipboard.writeText(url);
      setStatus(badge('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞', 'ok'));
    } catch {
      setStatus(badge('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å', 'err'));
    }
  };

  const setupAudioMeters = (localStream, remoteStream) => {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const createMeter = (stream, analyserRef, meterEl) => {
        const source = audioCtx.createMediaStreamSource(stream);
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256;
        analyserRef.node = analyser;
        source.connect(analyser);
        const data = new Uint8Array(analyser.frequencyBinCount);
        const draw = () => {
          analyser.getByteTimeDomainData(data);
          let peak = 0;
          for (let i = 0; i < data.length; i++) {
            const v = (data[i] - 128) / 128;
            peak = Math.max(peak, Math.abs(v));
          }
          const pct = Math.min(100, Math.max(0, Math.round(peak * 160)));
          meterEl.style.width = pct + '%';
        };
        return draw;
      };
      localAnalyser = {};
      remoteAnalyser = {};
      const draws = [];
      if (localStream) draws.push(createMeter(localStream, localAnalyser, els.mLocal));
      if (remoteStream) draws.push(createMeter(remoteStream, remoteAnalyser, els.mRemote));
      const loop = () => {
        draws.forEach(fn => fn());
        rafId = requestAnimationFrame(loop);
      };
      loop();
    } catch (e) {
      log('Meters init error:', e?.message || e);
    }
  };

  const stopMeters = () => {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
    els.mLocal.style.width = '0%';
    els.mRemote.style.width = '0%';
    try { audioCtx && audioCtx.close(); } catch {}
    audioCtx = null;
  };

  const getMedia = async () => {
    const constraints = {
      audio: {
        channelCount: 2,
        sampleRate: 48000,
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      },
      video: false
    };
    log('–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É‚Ä¶');
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    els.localAudio.srcObject = stream;
    try { await els.localAudio.play(); } catch {}
    return stream;
  };

  const startStatsMonitor = (pc) => {
    clearInterval(statsTimer);
    statsTimer = setInterval(async () => {
      try {
        const stats = await pc.getStats();
        let codecLabel = null;
        let selectedCandidatePairId = null, candidatePair = null, localCand = null, remoteCand = null;

        stats.forEach(report => {
          if (report.type === 'inbound-rtp' && report.kind === 'audio' && report.codecId) {
            const codec = stats.get(report.codecId);
            if (codec && codec.mimeType) codecLabel = codec.mimeType + (codec.sdpFmtpLine ? ` (${codec.sdpFmtpLine})` : '');
          }
          if (report.type === 'transport' && report.selectedCandidatePairId) {
            selectedCandidatePairId = report.selectedCandidatePairId;
          }
        });
        if (selectedCandidatePairId) candidatePair = stats.get(selectedCandidatePairId);
        if (candidatePair) {
          localCand = stats.get(candidatePair.localCandidateId);
          remoteCand = stats.get(candidatePair.remoteCandidateId);
        }

        if (codecLabel) {
          els.codec.textContent = codecLabel;
          els.codec.className = 'badge ok';
        }
        if (localCand && remoteCand) {
          const text = `${localCand.protocol || 'udp'} ¬∑ ${localCand.candidateType} ‚áÑ ${remoteCand.candidateType}`;
          els.ice.textContent = text;
          els.ice.className = 'badge';
        }
      } catch (e) {
        // ignore single errors
      }
    }, 1500);
  };

  const cleanup = () => {
    if (call) { try { call.close(); } catch {} call = null; }
    if (peer) { try { peer.destroy(); } catch {} peer = null; }
    if (localStream) {
      localStream.getTracks().forEach(t => { try { t.stop(); } catch {} });
      localStream = null;
    }
    if (els.remoteAudio.srcObject) {
      const rs = els.remoteAudio.srcObject;
      if (rs && rs.getTracks) rs.getTracks().forEach(t => t.stop());
      els.remoteAudio.srcObject = null;
    }
    els.localAudio.srcObject = null;
    stopMeters();
    clearInterval(statsTimer);
    statsTimer = null;
    els.muteBtn.disabled = true;
    els.hangBtn.disabled = true;
    els.muteBtn.textContent = '–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω';
    setStatus(badge('–û—Ç–∫–ª—é—á–µ–Ω–æ'));
    els.role.textContent = '‚Äî';
    els.cid.textContent = '‚Äî';
    els.codec.textContent = '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
    els.codec.className = 'badge warn';
    els.ice.textContent = '‚Äî';
  };

  const attachCallHandlers = (mc) => {
    call = mc;
    const pc = mc.peerConnection || mc._pc || null;

    mc.on('stream', async (remoteStream) => {
      log('–ü–æ–ª—É—á–µ–Ω —É–¥–∞–ª—ë–Ω–Ω—ã–π –ø–æ—Ç–æ–∫');
      els.remoteAudio.srcObject = remoteStream;
      try { await els.remoteAudio.play(); } catch {}
      setupAudioMeters(localStream, remoteStream);
      els.muteBtn.disabled = false;
      els.hangBtn.disabled = false;
      if (pc) startStatsMonitor(pc);
    });

    mc.on('close', () => {
      log('–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à—ë–Ω');
      setStatus(badge('–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à—ë–Ω', 'warn'));
      cleanup();
    });

    mc.on('error', (e) => {
      log('–û—à–∏–±–∫–∞ –∑–≤–æ–Ω–∫–∞:', e?.type || e?.message || e);
      setStatus(badge('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è', 'err'));
    });

    if (pc) {
      pc.addEventListener('iceconnectionstatechange', () => {
        log('ICE state:', pc.iceConnectionState);
        if (pc.iceConnectionState === 'failed') {
          els.ice.className = 'badge err';
        }
      });
    }
  };

  const becomeHost = async (hostId) => {
    return new Promise((resolve, reject) => {
      peer = new Peer(hostId, PEER_OPTS);
      peer.on('open', id => {
        log('–ú—ã ‚Äî —Ö–æ—Å—Ç, ID:', id);
        isHost = true;
        els.role.textContent = '–•–æ—Å—Ç (–æ–∂–∏–¥–∞–Ω–∏–µ)';
        resolve(true);
      });
      peer.on('error', (e) => {
        log('Peer error (host):', e?.type || e?.message || e);
        if (e && (e.type === 'unavailable-id' || /taken|unavailable/i.test(e.message))) {
          resolve(false); // ID –∑–∞–Ω—è—Ç ‚Äî –±—É–¥–µ–º –∑–≤–æ–Ω–∏—Ç—å
        } else {
          reject(e);
        }
      });
      peer.on('call', (incoming) => {
        log('–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫ ‚Äî –æ—Ç–≤–µ—á–∞–µ–º');
        try {
          incoming.answer(localStream, { metadata: { opus: true } });
          attachCallHandlers(incoming);
          setStatus(badge('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ', 'ok'));
          els.role.textContent = '–•–æ—Å—Ç (–≤ –∑–≤–æ–Ω–∫–µ)';
        } catch (e) {
          log('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–≤–µ—Ç–∏—Ç—å:', e?.message || e);
          setStatus(badge('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ', 'err'));
        }
      });
    });
  };

  const becomeCaller = async (hostId) => {
    return new Promise((resolve, reject) => {
      peer = new Peer(undefined, PEER_OPTS);
      peer.on('open', () => {
        log('–ú—ã ‚Äî –∑–≤–æ–Ω—è—â–∏–π, PeerID:', peer.id);
        isHost = false;
        els.role.textContent = '–ö–ª–∏–µ–Ω—Ç (–∑–≤–æ–Ω—è—â–∏–π)';
        try {
          const mc = peer.call(hostId, localStream, { metadata: { opus: true } });
          if (!mc) {
            setStatus(badge('–•–æ—Å—Ç –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç', 'warn'));
            return reject(new Error('No media connection'));
          }
          attachCallHandlers(mc);
          setStatus(badge('–ó–≤–æ–Ω–∏–º‚Ä¶'));
          resolve(true);
        } catch (e) {
          log('–û—à–∏–±–∫–∞ –≤—ã–∑–æ–≤–∞:', e?.message || e);
          setStatus(badge('–û—à–∏–±–∫–∞ –≤—ã–∑–æ–≤–∞', 'err'));
          reject(e);
        }
      });
      peer.on('error', (e) => {
        log('Peer error (caller):', e?.type || e?.message || e);
        setStatus(badge('–û—à–∏–±–∫–∞ peer', 'err'));
      });
    });
  };

  const startOrJoin = async () => {
    els.startBtn.disabled = true;
    els.copyBtn.disabled = true;
    setStatus(badge('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è‚Ä¶'));

    let callId = sanitizeId(els.callId.value);
    if (!callId) callId = randomId();
    els.callId.value = callId;
    els.cid.textContent = callId;
    updateUrlHash(callId);

    try {
      localStream = await getMedia();
    } catch (e) {
      log('–î–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –æ—Ç–∫–ª–æ–Ω—ë–Ω:', e?.message || e);
      setStatus(badge('–ù—É–∂–µ–Ω –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É', 'err'));
      els.startBtn.disabled = false; els.copyBtn.disabled = false;
      return;
    }

    const hostId = callHostId(callId);
    setStatus(badge('–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ —Å–∏–≥–Ω–∞–ª—å–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—É‚Ä¶'));
    let hosting;
    try {
      hosting = await becomeHost(hostId);
    } catch (e) {
      log('–û—à–∏–±–∫–∞ —Å–∏–≥–Ω–∞–ª—å–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞:', e?.message || e);
      setStatus(badge('–°–∏–≥–Ω–∞–ª–∏–Ω–≥ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω', 'err'));
      els.startBtn.disabled = false; els.copyBtn.disabled = false;
      return;
    }

    if (!hosting) {
      // –•–æ—Å—Ç —É–∂–µ –µ—Å—Ç—å ‚Äî –∑–≤–æ–Ω–∏–º
      try {
        await becomeCaller(hostId);
      } catch (e) {
        setStatus(badge('–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–∑–≤–æ–Ω–∏—Ç—å—Å—è', 'err'));
      }
    } else {
      // –ú—ã ‚Äî —Ö–æ—Å—Ç –∏ –∂–¥—ë–º
      setStatus(badge('–ñ–¥—ë–º –≤—Ç–æ—Ä–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞‚Ä¶', 'warn'));
    }

    els.hangBtn.disabled = false;
    els.copyBtn.disabled = false;
  };

  const hangup = () => {
    cleanup();
    els.startBtn.disabled = false;
  };

  const toggleMute = () => {
    if (!localStream) return;
    const track = localStream.getAudioTracks()[0];
    if (!track) return;
    track.enabled = !track.enabled;
    els.muteBtn.textContent = track.enabled ? '–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω' : '–í–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω';
  };

  // Wire UI
  els.startBtn.addEventListener('click', startOrJoin);
  els.copyBtn.addEventListener('click', copyLink);
  els.hangBtn.addEventListener('click', hangup);
  els.muteBtn.addEventListener('click', toggleMute);

  // –ê–≤—Ç–æ–ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∞ ID –∏–∑ URL
  const hashId = decodeURIComponent((location.hash || '').replace(/^#/, ''));
  if (hashId) {
    els.callId.value = sanitizeId(hashId);
  }

  // –ü–æ–ª–µ–∑–Ω—ã–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏
  log('–ì–æ—Ç–æ–≤–æ. –í–≤–µ–¥–∏—Ç–µ –æ–±—â–∏–π ID –∑–≤–æ–Ω–∫–∞ –∏ –Ω–∞–∂–º–∏—Ç–µ "–°—Ç–∞—Ä—Ç / –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è".');
  log('–ü–µ—Ä–≤—ã–π, –∫—Ç–æ –∑–∞–π–¥—ë—Ç —Å ID, —Å—Ç–∞–Ω–µ—Ç —Ö–æ—Å—Ç–æ–º (–æ–∂–∏–¥–∞–Ω–∏–µ); –≤—Ç–æ—Ä–æ–π ‚Äî –¥–æ–∑–≤–æ–Ω–∏—Ç—Å—è –∫ –Ω–µ–º—É –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.');
  log('Codec: –í —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –±—Ä–∞—É–∑–µ—Ä–∞—Ö –¥–ª—è –∞—É–¥–∏–æ WebRTC –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–±–∏—Ä–∞–µ—Ç Opus 48kHz.');
  log('–ü–æ–¥ –∫–∞–ø–æ—Ç–æ–º: PeerJS (–æ–±–ª–∞—á–Ω—ã–π signaling), STUN Google. –î–ª—è –∂—ë—Å—Ç–∫–∏—Ö NAT –º–æ–∂–µ—Ç –ø–æ–Ω–∞–¥–æ–±–∏—Ç—å—Å—è TURN (–Ω–µ –≤—Ö–æ–¥–∏—Ç).');
})();
</script>
</body>
</html>

==================================================

<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>–ó–≤–æ–Ω–∫–∏ (WebRTC + Opus) ‚Äî –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞</title>
  <meta name="description" content="–ê—É–¥–∏–æ–∑–≤–æ–Ω–∫–∏ —á–µ—Ä–µ–∑ WebRTC –∏ Opus –±–µ–∑ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞. –†–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–º —Ö–æ—Å—Ç–∏–Ω–≥–µ (Vercel/Replit)." />
  <link rel="icon" href="data:,">
  <style>
    :root {
      --bg: #0f1220;
      --panel: #151934;
      --text: #e9ecf1;
      --muted: #a9b0c3;
      --accent: #7c9cff;
      --ok: #34d399;
      --warn: #f59e0b;
      --err: #ef4444;
      --border: #28304f;
    }
    * { box-sizing: border-box; }
    html, body { margin: 0; padding: 0; height: 100%; }
    body {
      font: 14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
      color: var(--text);
      background: radial-gradient(1200px 1200px at 10% 10%, #151934 0%, #0f1220 45%, #0a0d1a 100%);
      overflow-y: auto;
    }
    .wrap {
      max-width: 900px;
      margin: 32px auto;
      padding: 0 16px;
    }
    .card {
      background: rgba(21, 25, 52, 0.88);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 20px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.25);
      backdrop-filter: blur(6px);
    }
    h1 {
      margin: 0 0 12px 0;
      font-size: 22px; font-weight: 700;
      display: flex; align-items: center; gap: 8px;
    }
    .sub { color: var(--muted); margin-bottom: 14px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .row > * { flex: 1 1 auto; }
    input[type="text"] {
      background: #0f132a;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px 14px;
      outline: none;
      width: 100%;
      transition: border-color .15s ease;
      font-size: 15px;
    }
    input[type="text"]:focus { border-color: var(--accent); }
    button {
      background: linear-gradient(180deg, #6c8cff 0%, #5a7bff 100%);
      color: white;
      border: none;
      border-radius: 10px;
      padding: 12px 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform .06s ease, filter .2s ease;
      user-select: none;
      white-space: nowrap;
    }
    button.secondary {
      background: #21284a;
      color: #dbe1ff;
      border: 1px solid #2c3563;
    }
    button:disabled { filter: grayscale(.6) brightness(.85); cursor: not-allowed; }
    button:active { transform: translateY(1px); }
    .grid {
      display: grid; gap: 14px; margin-top: 16px;
      grid-template-columns: repeat(12, 1fr);
    }
    .panel {
      background: #0f132a;
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
    }
    .panel h3 { margin: 0 0 10px 0; font-size: 14px; color: var(--muted); }
    .status {
      display: flex; align-items: center; gap: 10px; flex-wrap: wrap;
      font-size: 14px;
    }
    .badge {
      display: inline-flex; align-items: center; gap: 6px;
      border-radius: 999px; padding: 6px 10px; font-size: 12px; font-weight: 600;
      border: 1px solid var(--border);
      background: #121738;
      color: #dfe6ff;
    }
    .badge.ok { background: rgba(52, 211, 153, .12); color: #bbf7d0; border-color: rgba(52, 211, 153, .25); }
    .badge.warn { background: rgba(245, 158, 11, .12); color: #fde68a; border-color: rgba(245, 158, 11, .25); }
    .badge.err { background: rgba(239, 68, 68, .12); color: #fecaca; border-color: rgba(239, 68, 68, .25); }
    .controls { display: flex; gap: 10px; flex-wrap: wrap; }
    .meter {
      height: 10px; border-radius: 6px; background: #0c1124; border: 1px solid var(--border);
      overflow: hidden; position: relative;
    }
    .meter > i {
      position: absolute; left: 0; top: 0; bottom: 0; width: 0%;
      background: linear-gradient(90deg, #34d399 0%, #f59e0b 60%, #ef4444 100%);
      transition: width .08s linear;
    }
    .caption { color: var(--muted); font-size: 12px; margin-top: 6px; }
    .small { font-size: 12px; color: var(--muted); }
    code.mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; padding: 2px 6px; border: 1px solid var(--border); border-radius: 6px; background: #0f132a; color: #dbe1ff; }
    .logs { height: 160px; overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; background: #0c1124; border-radius: 8px; border: 1px solid var(--border); padding: 10px; white-space: pre-wrap; }
    .hint { color: var(--muted); }
    @media (max-width: 860px) {
      .grid { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>üîä –í–µ–±-–∑–≤–æ–Ω–∫–∏ –Ω–∞ Opus (WebRTC, –±–µ–∑ —Å–µ—Ä–≤–µ—Ä–∞)</h1>
    <div class="sub">–û–¥–Ω–æ—Å—Ç—Ä–∞–Ω–∏—á–Ω—ã–π –º–µ—Å—Å–µ–Ω–¥–∂–µ—Ä –¥–ª—è –∞—É–¥–∏–æ-–∑–≤–æ–Ω–∫–æ–≤. –†–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–µ—Ç—Å—è –∫–∞–∫ —Å—Ç–∞—Ç–∏–∫ (Vercel/Replit). –°–∏–≥–Ω–∞–ª–∏–Ω–≥ ‚Äî –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π –æ–±–ª–∞—á–Ω—ã–π PeerJS; NAT ‚Äî –ø—É–±–ª–∏—á–Ω—ã–µ STUN. –ö–æ–¥–µ–∫ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é ‚Äî Opus 48 kHz.</div>

    <div class="row" style="margin-bottom: 10px;">
      <input id="callId" type="text" placeholder="ID –∑–≤–æ–Ω–∫–∞ (–Ω–∞–ø—Ä–∏–º–µ—Ä: team-42)" autocomplete="off" />
      <button id="startBtn">–°—Ç–∞—Ä—Ç / –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è</button>
      <button id="copyBtn" class="secondary" title="–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É —Å ID">–°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É</button>
    </div>

    <div class="grid">
      <div class="panel" style="grid-column: span 8;">
        <h3>–°—Ç–∞—Ç—É—Å</h3>
        <div class="status" id="status">
          <span class="badge">–ù–µ –∑–∞–ø—É—â–µ–Ω–æ</span>
        </div>
        <div class="controls" style="margin-top: 12px;">
          <button id="muteBtn" class="secondary" disabled>–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω</button>
          <button id="hangBtn" class="secondary" disabled>–ó–∞–≤–µ—Ä—à–∏—Ç—å</button>
        </div>
        <div class="row" style="margin-top: 12px;">
          <div style="flex:1">
            <div class="small">–õ–æ–∫–∞–ª—å–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å</div>
            <div class="meter"><i id="mLocal"></i></div>
          </div>
          <div style="flex:1">
            <div class="small">–£–¥–∞–ª—ë–Ω–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å</div>
            <div class="meter"><i id="mRemote"></i></div>
          </div>
        </div>
      </div>

      <div class="panel" style="grid-column: span 4;">
        <h3>–¢–µ–∫—É—â–∞—è —Å–µ—Å—Å–∏—è</h3>
        <div class="small">–†–æ–ª—å: <span id="role">‚Äî</span></div>
        <div class="small">ID –∑–≤–æ–Ω–∫–∞: <code id="cid" class="mono">‚Äî</code></div>
        <div class="small">Codec (inbound): <span id="codec" class="badge warn">–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ</span></div>
        <div class="small">ICE: <span id="ice" class="badge">‚Äî</span></div>
        <div class="hint" style="margin-top:10px;">
          –°—Å—ã–ª–∫–∞ –Ω–∞ –∑–≤–æ–Ω–æ–∫ —Ö—Ä–∞–Ω–∏—Ç—Å—è –≤ URL (#id). –û—Ç–ø—Ä–∞–≤—å—Ç–µ –µ—ë —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫—É ‚Äî –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å —Ç–µ–º –∂–µ ID –≤—Ç–æ—Ä–æ–π —É—á–∞—Å—Ç–Ω–∏–∫ –ø–æ–¥–∫–ª—é—á–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.
        </div>
      </div>

      <div class="panel" style="grid-column: span 12;">
        <h3>–õ–æ–≥–∏</h3>
        <div class="logs" id="logs"></div>
      </div>
    </div>
  </div>
</div>

<!-- –°–∫—Ä—ã—Ç—ã–µ –∞—É–¥–∏–æ —ç–ª–µ–º–µ–Ω—Ç—ã -->
<audio id="localAudio" autoplay muted playsinline></audio>
<audio id="remoteAudio" autoplay playsinline></audio>

<!-- PeerJS —Å CDN (–æ–±–ª–∞—á–Ω—ã–π —Å–∏–≥–Ω–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä 0.peerjs.com) -->
<script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
<script>
(() => {
  const els = {
    callId: document.getElementById('callId'),
    startBtn: document.getElementById('startBtn'),
    copyBtn: document.getElementById('copyBtn'),
    muteBtn: document.getElementById('muteBtn'),
    hangBtn: document.getElementById('hangBtn'),
    status: document.getElementById('status'),
    cid: document.getElementById('cid'),
    role: document.getElementById('role'),
    codec: document.getElementById('codec'),
    ice: document.getElementById('ice'),
    logs: document.getElementById('logs'),
    localAudio: document.getElementById('localAudio'),
    remoteAudio: document.getElementById('remoteAudio'),
    mLocal: document.getElementById('mLocal'),
    mRemote: document.getElementById('mRemote'),
  };

  const ICE_SERVERS = [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' },
  ];
  const PEER_OPTS = {
    debug: 1,
    // signaling ‚Äî –æ–±–ª–∞—á–Ω—ã–π —Å–µ—Ä–≤–µ—Ä PeerJS (0.peerjs.com) –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    config: { iceServers: ICE_SERVERS }
  };

  let peer = null;
  let isHost = false;
  let call = null;
  let localStream = null;
  let statsTimer = null;
  let audioCtx, localAnalyser, remoteAnalyser, rafId;

  const log = (...args) => {
    const msg = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
    const time = new Date().toLocaleTimeString();
    els.logs.textContent += `[${time}] ${msg}\n`;
    els.logs.scrollTop = els.logs.scrollHeight;
    console.log('[LOG]', ...args);
  };
  const setStatus = (...badges) => {
    els.status.innerHTML = '';
    badges.forEach(b => els.status.appendChild(b));
  };
  const badge = (text, type='') => {
    const s = document.createElement('span');
    s.className = 'badge' + (type ? ' ' + type : '');
    s.textContent = text;
    return s;
  };

  const sanitizeId = (s) => (s || '')
    .toLowerCase()
    .replace(/[^a-z0-9_-]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .slice(0, 48);

  const randomId = () =>
    Math.random().toString(36).slice(2, 6) + '-' + Math.random().toString(36).slice(2, 6);

  const callHostId = (callId) => `call-${callId}-host`;

  const updateUrlHash = (callId) => {
    const url = location.origin + location.pathname + '#' + encodeURIComponent(callId);
    history.replaceState(null, '', url);
  };
  const copyLink = async () => {
    const callId = sanitizeId(els.callId.value);
    if (!callId) return;
    const url = location.origin + location.pathname + '#' + encodeURIComponent(callId);
    try {
      await navigator.clipboard.writeText(url);
      setStatus(badge('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞', 'ok'));
    } catch {
      setStatus(badge('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å', 'err'));
    }
  };

  const setupAudioMeters = (localStream, remoteStream) => {
    try {
      audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const createMeter = (stream, analyserRef, meterEl) => {
        const source = audioCtx.createMediaStreamSource(stream);
        const analyser = audioCtx.createAnalyser();
        analyser.fftSize = 256;
        analyserRef.node = analyser;
        source.connect(analyser);
        const data = new Uint8Array(analyser.frequencyBinCount);
        const draw = () => {
          analyser.getByteTimeDomainData(data);
          let peak = 0;
          for (let i = 0; i < data.length; i++) {
            const v = (data[i] - 128) / 128;
            peak = Math.max(peak, Math.abs(v));
          }
          const pct = Math.min(100, Math.max(0, Math.round(peak * 160)));
          meterEl.style.width = pct + '%';
        };
        return draw;
      };
      localAnalyser = {};
      remoteAnalyser = {};
      const draws = [];
      if (localStream) draws.push(createMeter(localStream, localAnalyser, els.mLocal));
      if (remoteStream) draws.push(createMeter(remoteStream, remoteAnalyser, els.mRemote));
      const loop = () => {
        draws.forEach(fn => fn());
        rafId = requestAnimationFrame(loop);
      };
      loop();
    } catch (e) {
      log('Meters init error:', e?.message || e);
    }
  };

  const stopMeters = () => {
    if (rafId) cancelAnimationFrame(rafId);
    rafId = null;
    els.mLocal.style.width = '0%';
    els.mRemote.style.width = '0%';
    try { audioCtx && audioCtx.close(); } catch {}
    audioCtx = null;
  };

  const getMedia = async () => {
    const constraints = {
      audio: {
        channelCount: 2,
        sampleRate: 48000,
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      },
      video: false
    };
    log('–ó–∞–ø—Ä–∞—à–∏–≤–∞–µ–º –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É‚Ä¶');
    const stream = await navigator.mediaDevices.getUserMedia(constraints);
    els.localAudio.srcObject = stream;
    try { await els.localAudio.play(); } catch {}
    return stream;
  };

  const startStatsMonitor = (pc) => {
    clearInterval(statsTimer);
    statsTimer = setInterval(async () => {
      try {
        const stats = await pc.getStats();
        let codecLabel = null;
        let selectedCandidatePairId = null, candidatePair = null, localCand = null, remoteCand = null;

        stats.forEach(report => {
          if (report.type === 'inbound-rtp' && report.kind === 'audio' && report.codecId) {
            const codec = stats.get(report.codecId);
            if (codec && codec.mimeType) codecLabel = codec.mimeType + (codec.sdpFmtpLine ? ` (${codec.sdpFmtpLine})` : '');
          }
          if (report.type === 'transport' && report.selectedCandidatePairId) {
            selectedCandidatePairId = report.selectedCandidatePairId;
          }
        });
        if (selectedCandidatePairId) candidatePair = stats.get(selectedCandidatePairId);
        if (candidatePair) {
          localCand = stats.get(candidatePair.localCandidateId);
          remoteCand = stats.get(candidatePair.remoteCandidateId);
        }

        if (codecLabel) {
          els.codec.textContent = codecLabel;
          els.codec.className = 'badge ok';
        }
        if (localCand && remoteCand) {
          const text = `${localCand.protocol || 'udp'} ¬∑ ${localCand.candidateType} ‚áÑ ${remoteCand.candidateType}`;
          els.ice.textContent = text;
          els.ice.className = 'badge';
        }
      } catch (e) {
        // ignore single errors
      }
    }, 1500);
  };

  const cleanup = () => {
    if (call) { try { call.close(); } catch {} call = null; }
    if (peer) { try { peer.destroy(); } catch {} peer = null; }
    if (localStream) {
      localStream.getTracks().forEach(t => { try { t.stop(); } catch {} });
      localStream = null;
    }
    if (els.remoteAudio.srcObject) {
      const rs = els.remoteAudio.srcObject;
      if (rs && rs.getTracks) rs.getTracks().forEach(t => t.stop());
      els.remoteAudio.srcObject = null;
    }
    els.localAudio.srcObject = null;
    stopMeters();
    clearInterval(statsTimer);
    statsTimer = null;
    els.muteBtn.disabled = true;
    els.hangBtn.disabled = true;
    els.muteBtn.textContent = '–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω';
    setStatus(badge('–û—Ç–∫–ª—é—á–µ–Ω–æ'));
    els.role.textContent = '‚Äî';
    els.cid.textContent = '‚Äî';
    els.codec.textContent = '–Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ';
    els.codec.className = 'badge warn';
    els.ice.textContent = '‚Äî';
  };

  const attachCallHandlers = (mc) => {
    call = mc;
    const pc = mc.peerConnection || mc._pc || null;

    mc.on('stream', async (remoteStream) => {
      log('–ü–æ–ª—É—á–µ–Ω —É–¥–∞–ª—ë–Ω–Ω—ã–π –ø–æ—Ç–æ–∫');
      els.remoteAudio.srcObject = remoteStream;
      try { await els.remoteAudio.play(); } catch {}
      setupAudioMeters(localStream, remoteStream);
      els.muteBtn.disabled = false;
      els.hangBtn.disabled = false;
      if (pc) startStatsMonitor(pc);
    });

    mc.on('close', () => {
      log('–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à—ë–Ω');
      setStatus(badge('–ó–≤–æ–Ω–æ–∫ –∑–∞–≤–µ—Ä—à—ë–Ω', 'warn'));
      cleanup();
    });

    mc.on('error', (e) => {
      log('–û—à–∏–±–∫–∞ –∑–≤–æ–Ω–∫–∞:', e?.type || e?.message || e);
      setStatus(badge('–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è', 'err'));
    });

    if (pc) {
      pc.addEventListener('iceconnectionstatechange', () => {
        log('ICE state:', pc.iceConnectionState);
        if (pc.iceConnectionState === 'failed') {
          els.ice.className = 'badge err';
        }
      });
    }
  };

  const becomeHost = async (hostId) => {
    return new Promise((resolve, reject) => {
      peer = new Peer(hostId, PEER_OPTS);
      peer.on('open', id => {
        log('–ú—ã ‚Äî —Ö–æ—Å—Ç, ID:', id);
        isHost = true;
        els.role.textContent = '–•–æ—Å—Ç (–æ–∂–∏–¥–∞–Ω–∏–µ)';
        resolve(true);
      });
      peer.on('error', (e) => {
        log('Peer error (host):', e?.type || e?.message || e);
        if (e && (e.type === 'unavailable-id' || /taken|unavailable/i.test(e.message))) {
          resolve(false); // ID –∑–∞–Ω—è—Ç ‚Äî –±—É–¥–µ–º –∑–≤–æ–Ω–∏—Ç—å
        } else {
          reject(e);
        }
      });
      peer.on('call', (incoming) => {
        log('–í—Ö–æ–¥—è—â–∏–π –∑–≤–æ–Ω–æ–∫ ‚Äî –æ—Ç–≤–µ—á–∞–µ–º');
        try {
          incoming.answer(localStream, { metadata: { opus: true } });
          attachCallHandlers(incoming);
          setStatus(badge('–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ', 'ok'));
          els.role.textContent = '–•–æ—Å—Ç (–≤ –∑–≤–æ–Ω–∫–µ)';
        } catch (e) {
          log('–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–≤–µ—Ç–∏—Ç—å:', e?.message || e);
          setStatus(badge('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–≤–µ—Ç–µ', 'err'));
        }
      });
    });
  };

  const becomeCaller = async (hostId) => {
    return new Promise((resolve, reject) => {
      peer = new Peer(undefined, PEER_OPTS);
      peer.on('open', () => {
        log('–ú—ã ‚Äî –∑–≤–æ–Ω—è—â–∏–π, PeerID:', peer.id);
        isHost = false;
        els.role.textContent = '–ö–ª–∏–µ–Ω—Ç (–∑–≤–æ–Ω—è—â–∏–π)';
        try {
          const mc = peer.call(hostId, localStream, { metadata: { opus: true } });
          if (!mc) {
            setStatus(badge('–•–æ—Å—Ç –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç', 'warn'));
            return reject(new Error('No media connection'));
          }
          attachCallHandlers(mc);
          setStatus(badge('–ó–≤–æ–Ω–∏–º‚Ä¶'));
          resolve(true);
        } catch (e) {
          log('–û—à–∏–±–∫–∞ –≤—ã–∑–æ–≤–∞:', e?.message || e);
          setStatus(badge('–û—à–∏–±–∫–∞ –≤—ã–∑–æ–≤–∞', 'err'));
          reject(e);
        }
      });
      peer.on('error', (e) => {
        log('Peer error (caller):', e?.type || e?.message || e);
        setStatus(badge('–û—à–∏–±–∫–∞ peer', 'err'));
      });
    });
  };

  const startOrJoin = async () => {
    els.startBtn.disabled = true;
    els.copyBtn.disabled = true;
    setStatus(badge('–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è‚Ä¶'));

    let callId = sanitizeId(els.callId.value);
    if (!callId) callId = randomId();
    els.callId.value = callId;
    els.cid.textContent = callId;
    updateUrlHash(callId);

    try {
      localStream = await getMedia();
    } catch (e) {
      log('–î–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É –æ—Ç–∫–ª–æ–Ω—ë–Ω:', e?.message || e);
      setStatus(badge('–ù—É–∂–µ–Ω –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É', 'err'));
      els.startBtn.disabled = false; els.copyBtn.disabled = false;
      return;
    }

    const hostId = callHostId(callId);
    setStatus(badge('–ü–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –∫ —Å–∏–≥–Ω–∞–ª—å–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—É‚Ä¶'));
    let hosting;
    try {
      hosting = await becomeHost(hostId);
    } catch (e) {
      log('–û—à–∏–±–∫–∞ —Å–∏–≥–Ω–∞–ª—å–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞:', e?.message || e);
      setStatus(badge('–°–∏–≥–Ω–∞–ª–∏–Ω–≥ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω', 'err'));
      els.startBtn.disabled = false; els.copyBtn.disabled = false;
      return;
    }

    if (!hosting) {
      // –•–æ—Å—Ç —É–∂–µ –µ—Å—Ç—å ‚Äî –∑–≤–æ–Ω–∏–º
      try {
        await becomeCaller(hostId);
      } catch (e) {
        setStatus(badge('–ù–µ —É–¥–∞–ª–æ—Å—å –¥–æ–∑–≤–æ–Ω–∏—Ç—å—Å—è', 'err'));
      }
    } else {
      // –ú—ã ‚Äî —Ö–æ—Å—Ç –∏ –∂–¥—ë–º
      setStatus(badge('–ñ–¥—ë–º –≤—Ç–æ—Ä–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞‚Ä¶', 'warn'));
    }

    els.hangBtn.disabled = false;
    els.copyBtn.disabled = false;
  };

  const hangup = () => {
    cleanup();
    els.startBtn.disabled = false;
  };

  const toggleMute = () => {
    if (!localStream) return;
    const track = localStream.getAudioTracks()[0];
    if (!track) return;
    track.enabled = !track.enabled;
    els.muteBtn.textContent = track.enabled ? '–í—ã–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω' : '–í–∫–ª—é—á–∏—Ç—å –º–∏–∫—Ä–æ—Ñ–æ–Ω';
  };

  // Wire UI
  els.startBtn.addEventListener('click', startOrJoin);
  els.copyBtn.addEventListener('click', copyLink);
  els.hangBtn.addEventListener('click', hangup);
  els.muteBtn.addEventListener('click', toggleMute);

  // –ê–≤—Ç–æ–ø–æ–¥—Å—Ç–∞–Ω–æ–≤–∫–∞ ID –∏–∑ URL
  const hashId = decodeURIComponent((location.hash || '').replace(/^#/, ''));
  if (hashId) {
    els.callId.value = sanitizeId(hashId);
  }

  // –ü–æ–ª–µ–∑–Ω—ã–µ –ø–æ–¥—Å–∫–∞–∑–∫–∏
  log('–ì–æ—Ç–æ–≤–æ. –í–≤–µ–¥–∏—Ç–µ –æ–±—â–∏–π ID –∑–≤–æ–Ω–∫–∞ –∏ –Ω–∞–∂–º–∏—Ç–µ "–°—Ç–∞—Ä—Ç / –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è".');
  log('–ü–µ—Ä–≤—ã–π, –∫—Ç–æ –∑–∞–π–¥—ë—Ç —Å ID, —Å—Ç–∞–Ω–µ—Ç —Ö–æ—Å—Ç–æ–º (–æ–∂–∏–¥–∞–Ω–∏–µ); –≤—Ç–æ—Ä–æ–π ‚Äî –¥–æ–∑–≤–æ–Ω–∏—Ç—Å—è –∫ –Ω–µ–º—É –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.');
  log('Codec: –í —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –±—Ä–∞—É–∑–µ—Ä–∞—Ö –¥–ª—è –∞—É–¥–∏–æ WebRTC –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤—ã–±–∏—Ä–∞–µ—Ç Opus 48kHz.');
  log('–ü–æ–¥ –∫–∞–ø–æ—Ç–æ–º: PeerJS (–æ–±–ª–∞—á–Ω—ã–π signaling), STUN Google. –î–ª—è –∂—ë—Å—Ç–∫–∏—Ö NAT –º–æ–∂–µ—Ç –ø–æ–Ω–∞–¥–æ–±–∏—Ç—å—Å—è TURN (–Ω–µ –≤—Ö–æ–¥–∏—Ç).');
})();
</script>
</body>
</html>